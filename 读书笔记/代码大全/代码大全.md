# 代码大全

- [一、欢迎进入软件创建世界](#一、欢迎进入软件创建世界)
    - [软件开发的工作的主要方面](#软件开发的工作的主要方面)
    - [软件创建的重要性](#软件创建的重要性)
    - [欢迎进入软件创建世界小结](#欢迎进入软件创建世界小结)
- [二、利用隐喻对编程进行更深刻的理解](#二、利用隐喻对编程进行更深刻的理解)
    - [利用隐喻对编程进行更深刻的理解小结](#利用隐喻对编程进行更深刻的理解小结)
- [三、软件创建的先决条件](#三、软件创建的先决条件)
    - [先决条件的重要性](#先决条件的重要性)
    - [问题定义先决条件](#问题定义先决条件)
    - [需求分析先决条件](#需求分析先决条件)
        - [需求分析先决条件检查表](#需求分析先决条件检查表)
    - [结构设计先决条件](#结构设计先决条件)
        - [结构设计先决条件检查表](#结构设计先决条件检查表)
    - [选择语言的先决条件](#选择语言的先决条件)
    - [编程约定](#编程约定)
    - [软件创建的先决条件小结](#软件创建的先决条件小结)
- [四、建立子程序的步骤](#四、建立子程序的步骤)
    - [PDL(程序设计语言)](#PDL(程序设计语言))
    - [设计子程序](#设计子程序)
    - [检查子程序](#检查子程序)
    - [创建子程序检查表](#创建子程序检查表)
    - [建立子程序的步骤小结](#建立子程序的步骤小结)
- [五、高质量子程序的特点](#五、高质量子程序的特点)
    - [生成子程序的原因](#生成子程序的原因)
    - [子程序名称恰当](#子程序名称恰当)
    - [强内聚性](#强内聚性)
    - [松散耦合性](#松散耦合性)
    - [子程序长度](#子程序长度)
    - [防错性编程](#防错性编程)
    - [子程序参数](#子程序参数)
    - [使用函数](#使用函数)
    - [高质量的子程序检查表](#高质量的子程序检查表)
    - [高质量子程序的特点小结](#高质量子程序的特点小结)
- [六、模块化设计](#六、模块化设计)
- [七、高级结构设计](#七、高级结构设计)
- [八、生成数据](#八、生成数据)
- [九、数据名称](#九、数据名称)
- [十、变量](#十、变量)
- [十一、基本数据类型](#十一、基本数据类型)
- [十二、复杂数据类型](#十二、复杂数据类型)
- [十三、顺序程序语句](#十三、顺序程序语句)
- [十四、条件语句](#十四、条件语句)
- [十五、循环语句](#十五、循环语句)
- [十六、少见的控制结构](#十六、少见的控制结构)
- [十七、常见的控制问题](#十七、常见的控制问题)
- [十八、布局和风格](#十八、布局和风格)
- [十九、文档](#十九、文档)
- [二十、编程工具](#二十、编程工具)
- [二十一、项目大小如何影响创建](#二十一、项目大小如何影响创建)
- [二十二、创建管理](#二十二、创建管理)
- [二十三、软件质量概述](#二十三、软件质量概述)
- [二十四、评审](#二十四、评审)
- [二十五、单元测试](#二十五、单元测试)
- [二十六、调试](#二十六、调试)
- [二十七、系统集成](#二十七、系统集成)
- [二十八、代码调整策略](#二十八、代码调整策略)
- [二十九、代码调试技术](#二十九、代码调试技术)
- [三十、软件优化](#三十、软件优化)
- [三十一、个人性格](#三十一、个人性格)
    - [聪明和谦虚](#聪明和谦虚)
    - [好奇心](#好奇心)
    - [诚实](#诚实)
    - [交流和合作](#交流和合作)
    - [创造力和纪律](#创造力和纪律)
    - [懒惰](#懒惰)
    - [坚持](#坚持)
    - [经验](#经验)
    - [习惯](#习惯)
    - [个人性格小结](#个人性格小结)
- [三十二、软件开发方法的有关问题](#三十二、软件开发方法的有关问题)

## 一、欢迎进入软件创建世界

### 软件开发的工作的主要方面
- 问题定义 system specification
- 需求分析 requirements analysis
- 实现计划 
- 总体设计 architecural design
- 详细设计 detailed design
- 创建即实现 coding and debugging
    - 验证基础工作已经完成，可以进行创建工作
    - 设计和编写子程序与模块
    - 创立数据类型并命名变量
    - 选择控制结构并组织语句块
    - 找出错误并修正
    - 评审其他小组的细节设计和代码，同时接受其他小组评审
    - 通过仔细地格式化和征集意见改进编码
    - 对分别完成的软件单元进行综合
    - 调整编码使其更小、更快
- 系统综合 
- 单元测试 unit testing
- 系统测试 system testing
- 校正性维护 maintenance
- 功能强化 

### 软件创建的重要性
1. 创建活动是开发软件的重要组成部分
2. 创建活动在软件开发中处于枢纽地位
3. 把主要精力集中于创建活动，可以极大地提高程序员的工作效率
4. 创建活动的产品，源代码，往往是软件的唯一精确描述
5. 创建活动是唯一一项必不可少的工作

### 欢迎进入软件创建世界小结
- 创建活动是总体设计和系统测试之间承上启下的工作。
- 创建活动主要包括：详细设计、编码、调试和单元测试。
- 关于创建活动的其它称谓有：实现、编程等。
- 创建活动质量对软件质量有潜在影响。
- 在最后的分析中，对创建活动理解的好坏，决定了一个程序员素质的高低。




## 二、利用隐喻对编程进行更深刻的理解
常用隐喻：
- 软件书写：写代码 Write Code
- 软件播种：生成系统 Growing a System
- 软件珍珠培植法：系统积累 System Accretion
- 软件创建：建造软件 building software
- 实用软件技术：智能工具箱 The Intellectual Toolbox

### 利用隐喻对编程进行更深刻的理解小结
隐喻仅仅是启发，而不是公式，因此，它们更倾向于比较随便，无拘无束。
- 隐喻通过把软件开发与你所熟知的事情联系在一起，从而使你对其有更深刻的理解。
- 一些隐喻要好于其它隐喻。
- 把软件创建与建造建筑物类比，表明开发软件前要精心准备，并表明了大规模项目与小规模项目之间的差别。
- 认为软件开发实践是智能工具箱中的工具进一步表明，每个程序员都有许多自己的工具，没有任何一种工具是万能的。为每件工作选择合适的工具，是成为一个优秀程序员的首要素质之一。




## 三、软件创建的先决条件
### 先决条件的重要性
在进行创建工作前必须做准备工作的论据
- 逻辑推理：
    - 运行有效程序设计的关键之一就是认识到准备工作是非常重要的
- 类比：
    - 创建一个软件系统与其他需要耗费人力与财力的工程是一样的
- 数据
    - 研究证明，一次完成是最好的选择，不必要的修改是非常昂贵的

错误引入和发现时间不同，产生修复他们所要耗费的相对成本差异：
| 错误发现时间 | 需求分析 | 细节设计 | 编码 |
| ------------ | -------- | -------- | ---- |
| 需求分析     | 1        | -        | -    |
| 细节设计     | 2        | 1        | -    |
| 波动测试     | 5        | 2        | 1    |
| 结构测试     | 15       | 5        | 2    |
| 功能测试     | 25       | 10       | 5    |

### 问题定义先决条件
问题定义只描述要解决的问题是什么，根本不涉及解决方法。
问题定义应该从用户的观点出发，使用用户的语言进行定义。

### 需求分析先决条件
在创建各阶段如何应对需求变化：
- 用检查表评估需求分析质量
- 让每个人都知道由于变化需求所付出的代价
- 建立一套更改控制过程
- 用开发的方法来容纳变动
- 放弃项目

#### 需求分析先决条件检查表
**需求内容**
- 系统的所有输入都定义了吗？包括他们的来源、精度、取值范围和频率？
- 系统所有的输出都定义了吗？包括他们的目标、精度、取值范围、频率和格式？
- 所有的报告格式都定义了吗？
- 所有的硬件与软件接口都定义了吗？
- 所有的通信交互界面都定义了吗？包括握手、错误检查以及通信约定？
- 是否从用户的观点出发，定义了所有的必要操作的反应时间？
- 是否定义了时间问题，如处理时间、数据传输率以及系统吞吐能力？
- 是否对用户所有要求完成的任务都作出了规定？
- 每项任务所需用到和产生的数据都规定了吗？
- 规定保密级别了吗？
- 规定可靠性了吗？包括软件出错的后果、在出错时要保护的至关重要的信息、以及错误测试和恢复策略。
- 规定所需最大内存了吗？
- 所需最大存储容量规定了吗？
- 对系统的维护性是否作出了规定？包括系统对运行环境、精度、性能与其他软件的接口等方面变化的适应能力规定了吗？
- 是否规定了相互冲突的设计之间的折衷原则，例如，在坚固性与准确性之间如何进行折衷？
- 是否制定了系统成败的标准？

**关于需求的完善性**
- 在开发开始前暂时得不到的信息是什么？是否规定了不够完善的区域？
- 需求定义是否已经完善到了可以成为软件标准的地步？
- 需求中是否有那一部分令你感到不安？有没有根本不可能实现，而仅仅是为了取悦老板和用户才加进来的内容？

**关于需求的质量**
- 需求是否是用用户的语言制定的？用户也是这样认为的吗？
- 需求中是否每一条之间都尽量避免冲突？
- 需求中是否注意了避免规定设计工作？
- 需求在详细程度方面是否保持了一致性：有没有应该更详细的需求？有没有应该更简略些的？
- 需求是否明确到可以分为一些独立的可执行部分，而每一部分又都很明确？
- 是否每一条都与问题的答案相关？是否每一条都可以追溯到产生它的环境中？
- 是否每一条需求都可以作为测试依据？是否可以针对每一条进行单独测试以确定是否满足需求？
- 是否对可能的改动作出了规定？包括每一条改动的可能性？

### 结构设计先决条件
典型的结构要素：
- 程序的组织形式
- 变更策略：设计中已经考虑到了可能的功能增强变动，而且，应该使最可能的变动同时是最容易实现的变动。
- 购买而不是建造的决定：重新使用旧软件是提高生产率的首要因素。购买代码可以降低计划、详细设计、测试和调试的工作量。
- 主要的数据结构
    - 关键算法
- 主要对象
- 通用功能
    - 用户界面
    - 输入/输出
    - 内存管理
    - 字符串存储
- 错误处理
    - 错误处理是纠正错误还是仅仅测试错误？
    - 错误测试时主动还是被动的？
    - 程序是怎样对付错误的？
    - 处理错误信息的约定是什么呢？
    - 在程序中，应该在哪一个层次上处理错误呢？
    - 每一个模块检验输入数据合法性的责任级别有多搞？
- 坚固性 Robustness
    - 裕度设计 over-engineering 
    - 断言 assertions 
    - 容错性 fault toerance
        - 系统可以返回并重新开始
        - 发现错误时，系统可以用辅助代码来代替基本代码
        - 系统可以采用投票算法
        - 系统可以用一个假想值来代替错误的结果，以避免对程序其余部分的不良影响
    - 性能

通用结构设计质量准则
#### 结构设计先决条件检查表
- 软件的总体组织形式是否清晰明了？包括对与结构设计的总体评论与描述。
- 模块定义是否清楚？包括他们呢的功能以及与其他模块的接口。
- 要求定义中所提出的所有功能，是否有恰当数量的模块覆盖？
- 结构设计是否考虑了可能的更改？
- 是否包括了必要的购买？
- 是否阐明了如何改进重新启用的代码来满足现在的结构设计需求？
- 是否描述并验证了所有主要的数据结构？
- 主要数据结构是否隐藏在存取子程序中？
- 规定数据库组织形式和其他内容了吗？
- 是否说明并验证所有关键算法？
- 是否说明验证所有主要目标？
- 说明处理用户输入的策略了吗？
- 说明并验证处理输入/输出的策略了吗？
- 是否定义了用户界面的关键方面？
- 用户界面是否进行了模块化，以使对它所作的改动不会影响程序其他部分
- 是否描述并验证了内存使用估算和内存管理
- 是否对每一模块给出了存储空间和速度限制
- 是否说明了字符串处理策略？是否提供了对字符串占用空间的估计？
- 所提供的错误处理策略是否一致？
- 是否对错误信息进行了成套化管理以提供一个整洁的用户界面？
- 是否指定了坚固性级别？
- 有没有哪一部分结构设计被过分定义或缺少定义了？
- 是否明确提出了系统目标？
- 整个结构在概念哈桑是否一致？
- 机器和使用实现语言是否顶层设计依赖？
- 给出做出每个重要决定的动机了吗？
- 你作为系统实现者的程序员，对结构设计满意吗？

### 选择语言的先决条件
当程序员使用自己所熟悉的语言时，其工作效率比使用陌生的语言高得多。

### 编程约定
实现时在给变量和子程序命名、进行格式约定和注释约定时的指导方针。

### 软件创建的先决条件小结
- 如果想开发一个高质量的软件，必须自始至终重视质量问题。在开始阶段强调质量往往比在最后强调质量更为有效。
- 程序员的份内工作之一便是向老板和同事宣传软件的开发过程，包括在编程开始前从事先决条件准备工作的重要性。
- 如果问题定义工作做得不好，那么在创建阶段，所解决的问题可能并不是用户真正要解决的问题。
- 如果需求分析工作做得不好，很可能因此而漏掉要解决问题中的重要细节。在创建工作后更改要求，要比在需求分析阶段进行更改的成本高 20 到 100 倍。所以，在开始编程前一定要确认要求定义工作一切正常。
- 在编程前规定好约定，在创建工作结束后再改变代码来满足约定几乎是不可能的。
- 在创建活动开始之前如果无法完成准备工作，可以尝试在不太稳固的基础上进行创建活动。



## 四、建立子程序的步骤
### PDL(程序设计语言)
定义：
- 用模拟英语的语句来精确描述每一个特定的操作
- 避免使用最终程序语言的语句
- 在设计意向这一层次上写PDL
- 在足够低的层次上写出PDL，它几乎可以自动生成代码

例子：
``` txt
Keep track of current number of resource in use
If another resource is available
    Allocate a dialog box structure
    If a dialog box structure could be allocated
        Note that one more resource is in use
        Initialize the resource
        Store the resource number at the location provided by the caller
    Endif
Endif
Return TRUE if a new resource was created; else return FALSE
```

更高层级例子：
``` txt
This routine outputs an error message based on an error code supplied by the calling routine. The way it outputs the message depends on the current processing state, which it retrieves on its own. It returns a variable indicating success or failure.

set the default status
look up the message based on the error code
if the error code is valid 
    datermine the processing method
    if doing interactive processing
        print the error message interactively and declare success
    else doing batch processing
        if the batch message file opens properly
            log the error message to the batch file,
                close the file, and declare success
else the message code is not valid
    notify the user that an interal error has been detected
```

优点：
- PDL可以使评审工作变得更容易
- PDL可以帮助实现逐步细化的思想
- PDL使变动工作变得很容易
- PDL极大的减少了注释工作量
- PDL比其他形式的设计文件更容易维护

### 设计子程序
结构设计需要指出的问题：
- 这个子程序将要隐含的信息
- 这个子程序的输入
- 这个子程序的输出，包括受影响的全局变量
- 这个子程序将如何处理错误

步骤：
- 给子程序命名
- 考虑效率
- 研究算法和数据结构
- 编写PDL
- 编写工作应该从抽象到具体
- 考虑数据
- 逐步细化
- 书写子程序说明
- 非正式的检查代码
- 进行收尾工作
    - 检查子程序的接口
    - 检查通用设计质量
    - 检查子程序的数据
    - 检查子程序控制结构
    - 检查子程序设计
    - 检查子程序的文档
- 按需要重复步骤


### 检查子程序
- 在心里对子程序进行查错处理
- 编译子程序
    - 尽可能把比那一程序的警告等级调到最高
    - 消除所有编译程序指出的错误和提出警告的原因
- 使用计算机来检查子程序错误
- 消除子程序错误

### 创建子程序检查表
- 是否检查过先决条件是否已经满足了
- 定义子程序将要解决的问题了吗
- 结构设计是否足够清楚，使得你可以给子程序取个好名字
- 考虑如何测试子程序了吗
- 是否从模块化水平或者满足时间和内存要求角度考虑过效率问题
- 是否查阅过参考书：以寻求有帮助的算法
- 是否用详尽的PDL设计子程序
- 在必要时，是否在逻辑设计步骤前考虑了数据
- 是否检查过PDL，它很容易理解吗
- 是否注意到了足以使你返回结构设计阶段的警告
- 是否使用了PDL到代码流程，是否把PDL作为编码基础并把所有的PDL转为注释
- 是否精确地把PDL翻译成了代码
- 在作出假设时，验证它们了吗
- 是从几个设计方案中选择了最好的，还是随意选择了一个方案
- 是否彻底理解你的代码，它容易理解吗

### 建立子程序的步骤小结
- 要想写好 PDL，首先要用易懂的自然语言，避免拘泥于某种程序语言，其次要在意向层次上写 PDL，描述设计作什么而不是如何作。
- PDL 到代码流程方法是详细设计的有力工具，而且使得编码非常容易。可以把 PDL 直接翻译成注释，但要注意保证注释是精确而有用的。
- 应该在工作的每一步中都检查子程序，并鼓励同事们检查。这样，可以在投入的资金和工作努力最少时便发现错误，从而极大降低改错成本。



## 五、高质量子程序的特点
### 生成子程序的原因
- 降低复杂性
- 避免重复代码段
- 限制了改动带来的影响
- 隐含顺序
- 改进性能
- 进行集中控制
- 隐含数据结构
- 隐含全局变量
- 隐含指针操作
- 促进重新使用代码段
- 计划开发一个软件族
    - 如果想改进一个程序，最好把要改动的那部分放进子程序中，将其独立
- 提高部分代码的可读性
- 提高可移植性
- 分隔复杂操作
- 独立非标准语言函数的使用
- 简化复杂的布尔测试

### 子程序名称恰当
- 对过程的名字，可以用一个较强的动词带目标的形式
    - PrintReport / CheckOrderInfo
    - RePort.Print / OrderInfo.Check
- 对于函数名称，可以用返回值描述
    - Cos / PrinterReady / CurrentPenColor
- 避免无意义或模棱两可的动词
    -  ~~HandleCalculation / ProcessInput~~
- 描述子程序所做的而一切
    - ~~ComputeReportTotal~~
    - ~~TotalAndSetPrintingReadyVar~~
- 名字的长度要复合需要
- 建立用于通用操作的约定
    - GetInputChar / QueryInputChar

### 强内聚性
- 功能内聚
    - sin(), GetCustomerName(), EraseFile()
- 顺序内聚
    - DoStep1() / DoStep2()
- 通讯内聚型
    - GetNameAndChangePhoneNumber()
- 临时内聚性
    - Startup() / CompleteNewEmployee() / Shutdown()

### 松散耦合性
- 耦合性是指两个子程序之间联系的紧密程度
- 内聚性是指一个子程序的内部各部分之间的联系程度

#### 耦合标准
> 如果一个子程序越容易被其它子程序调用，那么它的耦合程度也就越低。这样
的好处是可以增强灵活性和维护性。在建立系统结构时，应该沿着相互耦合程度的最低线将其
分开。如果把程序看成一块木头的话，就是要沿着它的纹理把它劈开。
- 耦合规模：两个子程序之间联系的数量多少
- 密切性：两个子程序之间联系的直接程度，联系越直接越好，如：使用参数表中参数
- 可见性：两个子程序之间联系的显著程度，可见性越高越好
- 灵活性：改变两个子程序之间联系的容易程度

#### 耦合层次
- 简单数据耦合：连个子程序之间传递的数据是非结构化的，通过参数表进行的，通常称为"正常耦合"，也是最好的耦合
- 数据结构耦合：两个子程序之间传递的数据是结构化的，通过参数表进行的，与简单耦合的主要区别是采用的数据是结构化的
- 控制耦合：如果一个子程序通过传入另一个子程序的数据通知它应该做什么，这两个子程序就是控制耦合。控制耦合是令人不快的，因为它往往与逻辑内聚性联系在一起，并且，通常要求调用程序了解被调用子程序的内容与结构
- 全局数据耦合：两个子程序使用同一个全局数据，那它就是全局数据耦合。如果使用的数据是只读的，那么这种耦合还是可以热手的，但是，总的来说，全局耦合是不受欢迎的
- 不合理耦合：如果一个子程序使用了另外一个子程序中代码，或者改变了其中的局部变量，那么它们就是不合理耦合，这种耦合也称为"内容耦合"

### 子程序长度
- 理论上，常把一个子程序的最佳长度定为一两页，即66到132行

### 防错性编程
- 即使一个子程序被传入了坏数据，它也不会被伤害，哪怕这个数据是由其他干程序错误而产生的
- 承认程序中都会产生问题，都要被改动，一个聪明的程序员就以这点为依据开发软件

#### 使用断言
- 断言是一个在假设不正确时会大声抗议的函数或宏指令。
``` Pascal
Procedure Assert
(
    Assertionn: boolean;
    Message: string
)

begin
  if (not Assertion)
    begin
      writeln(Message);
      writeln('stopping the program.')
      halt(FATAL ERROR)
    end
end;
```

#### 输入垃圾不一定输出垃圾
- 

#### 异常情况处理
- 应预先设计好异常处理措施来注意意想不到的情况。
- 异常处理措施应该能使意外情况的出现在开发阶段变得非常明显，而在运行阶段又是可以修复的
- 如：开发阶段应该能利用异常情况产生一个警告，产品阶段应该做一些更完美的处理比如写如错误日志中
- 应该设计处不必费多大周折，就可以从开发阶段进入产品阶段的程序

#### 预计改动
- 在开发软件时，应该努力做到使它很容易地进行改动

#### 计划去掉调试帮助

#### 尽早引入调试辅助工具

#### 使用"防火墙"包容错误带来的危害

#### 在最终软件中保留多少防错性编程
- 保留查找未测试到错误的代码 - 多数用户宁愿忍受一个混乱的屏幕而不是错误的结果
- 去掉无关紧要错误的代码 - 通过版本控制预编译开关，而不是删除代码
- 去掉那些引起程序终止的代码 - 用户总希望有机会将其工作存盘
- 保留那些可以使程序延缓终止的代码 - 发生错误及时存盘退出，进行错误警告
- 保留在程序中的错误提示信息是友好的
- 要对防错性编程提高警惕 - 考虑好在哪里预防错误，防止程序变得臃肿而笨拙

### 子程序参数
- 确保实际参数与形式参数匹配
- 按照`输入-修改-输出`的顺序排列参数
- 如果几个程序使用了相似的参数，应按照不变的顺序排列这些参数
- 使用所有中的多数，如果向某个子程序中传入了一个参数，那就要在其中使用；如果不适用，就把它从子程序接口中去掉
- 把状态和"错误"变量放在最后
- 不要把子程序中的参教当作工作变量
- 说明参数的接口假设
    - 关于参数接口的哪些假设需要作出说明呢？
    - 参数是仅供输入的，修改的还是仅供输出的？
    - 数值参数的单位（英尺、码、还是米等）。
    - 如果没有使用枚举型参数的话，应指出状态参数和错误变量值的意义。
    - 预期的取值范围。
    - 永远不该出现的某些特定值。
- 应该把一个子程序的参数个数限制在7个
- 考虑建一个关于输入、修改和输出番薯的命名规则
- 仅传递子程序要的那部分结构变量
<del>- 不要对参数传制作出任何设想</del>

### 使用函数


### 高质量的子程序检查表
- 总体问题
    - 创建子程序的理由充分吗？
    - 如果把一个子程序中的某些部分独立成另一个子程序会更好的话，你这样做了吗？
    - 是否用了明显而清楚的动宾词组对过程进行命名？是否使用返回值的描述来命名函数？
    - 子程序的名称是否描述了它做的所有工作？
    - 子程序的内聚性是不是很强的功能内聚性？它只做了一件工作并做的很好吗？
    - 子程序的耦合是不是松散的？两个子程序之间的联系是不是小规模、密切、可见和灵活的？
    - 子程序的长度是不是它的功能和逻辑自然地决定的；而不是由人为标准决定的？
- 防错性编程
    - 断言是否用于验证假设？
    - 子程序对于非法输入数据进行防护了吗？
    - 子程序是否能很好地进行程序终止？
    - 子程序是否能很好地处理修改情况？
    - 是否不用很麻烦地启用或去掉调试帮助？
    - 是否信息隐蔽、松散耦合，以及使用"防火墙"数据检查，以使它不影响子程序之外的代码？
    - 子程序是否检查返回值？
    - 产品代码中的防错性代码是否帮助用户，而不是程序员？
- 参数传递问题
    - 形式参数和实际参数匹配吗？
    - 子程序中参数的排列合理吗？与相似子程序中的参数排列顺序匹配吗？
    - 接口假设说明了吗？
    - 子程序中参数个数是不是7个或更少？
    - 是否只传递了结构化变量中另一个子程序用得到的部分？
    - 是否用到了每一个输入参数？
    - 如果子程序是一函数，是否在所有情况下他都会返回一个值？

### 高质量子程序的特点小结
建立子程序的最重要原因是加强可管理性（即降低复杂性），其它原因还有节省空间、改进正确性、可靠性、可修改性等等。
- 强调强内聚性和松散耦合的首要原因是它们提供了较高层次的抽象性，你可以认为一个具备这种特性的子程序运行是独立的，这可以使你集中精力完成其它任务。
- 有些情况下，放入子程序而带来巨大收益的操作可能是非常简单的。
- 子程序的名称表明了它的质量，如果名称不好但却是精确的，那么说明它的设计也是非常令人遗憾的。如果一个子程序的名称既不好又不精确，那它根本就无法告诉你程序作了些什么。无论哪种情况，都说明程序需要改进。
- 防错性编程可以使错误更容易被发现和修复，对最终软件的危害性显著减小。


## 六、模块化设计
模块是指数据及作用域数据的子程序的集合。

### 模块化：内聚性和耦合性
- 模块化设计的目标是使每个子程序都成为一个"黑盒子"，你知道进入盒子和从盒子里出来的是什么，却不知道里面发生了什么。 

- 模块内聚性
    - 一个模块应该提供一组相互联系的服务
- 模块耦合
    - 模块应被设计成可以提供一整套功能，以便程序的其他部分与它清楚地相互作用
    - 在模块设计中的最重要决定之一，便是决定哪个子程序需要对模块中数据进行直接存取
    - 如果某个子程序仅仅是由于可以对模块中数据进行存取的原因才留在模块中的，那么，它应该被从模块中去掉

### 信息隐蔽
- 信息隐蔽也是结构化设计和面向对象设什的基础之一。
- 在结构设计中，黑盒子思想便来源于信息隐蔽。
- 在面向对象设计中，也是信息隐蔽引发了抽象化和封装化的设计思想。


### 模块的质量检查表
- 模块是否有一个中心目的
- 模块是否围绕着一组公用数据进行组织的
- 模块是否提供了一套相互联系的功能
- 模块功能是否足够完备，从而使得其他模块不必干扰其内部数据
- 一个模块相对其他模块是否是独立的？它们之间是松散耦合的吗？
- 一个模块的实现细节对其他模块来说是隐含的吗？
- 模块的接口是否抽象到了不必关心其功能实现方式的地步？它是作为一个黑盒子来设计的吗？
- 是否考虑过把模块再划分为单元模块？是否对其进行了充分的再划分
- 如果用不完全支持模块的语言编程，你是否制定了编程约定以使这种语言支持模块

### 模块化设计小节
- 不管调用哪一个，子程序与模块的不同使很重要的，要认真考虑子程序与模块的设计
- 从模块数据是被几个子程序使用的这一角度来说，他与全局数据是相同的，但从可以使用它的子程序是有限的，而且清楚地知道是哪些子程序可以使用它这一角度来说，模块数据与全局数据又是不同的。因此，可以使用模块数据而没有全局数据的危险
- 信息隐蔽总是有益的，其结果是可以产生可靠的易于改进的系统，它也是目前流行的设计方法的核心
- 创建模块的原因有许多是与创建子程序相同的。但模块概念的意义要比子程序深远得多，因为它可以提供一整套而不是单独一个功能，因此，它是比子程序更高层次的设计工具
- 可以在任何语言中进行模块设计。如果所采用的语言不直接支持模块，可以用编程约定对其加以扩展，以达到某种程度的模块化

## 七、高级结构设计

## 八、生成数据

## 九、数据名称

## 十、变量

## 十一、基本数据类型

## 十二、复杂数据类型

## 十三、顺序程序语句

## 十四、条件语句

## 十五、循环语句

## 十六、少见的控制结构

## 十七、常见的控制问题
### 布尔表达式
- 用 True 和 False 作为布尔变量，而不要用 0 和 1
- 在 C 中用 `1 == 1` 的形式定义 TRUE 和 FALSE
``` C
#define TRUE (1 == 1)
#define FALSE (!TRUE)
```
- 隐含地把布尔表达式与布尔值比较
``` C
while (not Done) // 不好写法 while (Done == False)
while (a == b)  // 不好写法 while ((a == b) == True)
```
- 使复杂的表达式简单些
    - 把复杂的测试条件用中间的布尔变量变成几个部分
    - 把复杂的表达式写成一个布尔型函数
    - 用决策代替复杂的条件
- 编写肯定形式的布尔型表达式
    - 在 if 语句中，把条件从否定形式转化为肯定形式，再把 if 和 else 语句后跟着的代码对调
    - 用 DeMorgen 定律去简化否定形式的布尔型判断条件
- 使用括号使布尔型表达式清晰
- 了解布尔型变量使怎样运算的
- 按数轴上的顺序编写数字算式
    - 按从小到大的顺序从左到右安排各部分
    - MinElmts <= i and i <= MaxElmts

#### DeMorgen 定律转换逻辑表达式
|   初始表达式    |      对应表达式       |
| --------------- | --------------------- |
| not A and not B | not (A or B)          |
| not A and B     | not (A or not B)      |
| A and not B     | not (not A or B)      |
| A and B         | not (not A and not B) |
| not A or not B  | not (A and B)         |
| not A or B      | not (A and not B)     |
| A or not B      | not (not A and B)     |
| A or B          | not (not A and not B) |

#### 防止危险的深层嵌套
- 通过重新编写部分判断条件来简化嵌套的 if 语句
- 把 if 嵌套 改成 case 语句
- 提取深层嵌套的代码写成一个子程序
- 重新设计深层嵌套代码
``` CPP
if (Error == None) 
{
    /* lots of code */
    
    if (PrinterRoutine != NULL) 
    {
        /* lots of code */
        
        if (SetupPage()) 
        {
            /* lots of code */
            
            if (AllocMem(&PrintData)) 
            {
                /* lots of code */
            }
        }
    }
}
```

## 十八、布局和风格

## 十九、文档

## 二十、编程工具

## 二十一、项目大小如何影响创建

## 二十二、创建管理

## 二十三、软件质量概述

## 二十四、评审

## 二十五、单元测试

## 二十六、调试

## 二十七、系统集成

## 二十八、代码调整策略

## 二十九、代码调试技术

## 三十、软件优化

## 三十一、个人性格
### 聪明和谦虚
"谦虚的程序员"
- "分解"一个系统的目的是为了使其更为简单易懂
- 进行评审、检查和测试使弥补人的错误的一种方法
- 将子程序编短一些有助于减少工作量
- 使用各种交谈方式可将你从编程的死胡同中解放出来

### 好奇心
- 在开发过程中建立自我意思
- 实验
- 阅读解决问题的有关方法
- 在行动前进行分析和计划
- 学习成功项目的开发经验
- 阅读手册
- 阅读有关书籍和期刊

### 诚实
- 不假装自己是一个编程高手
- 乐于承认自己的错误
- 力图理解编译器警告信息而不是对其置之不理
- 对你的程序有一个清晰的了解，而不是进行编译看其是否有错
- 提供实际状态报告
- 提供实际方案评估，在上级面前坚持自己的意见

### 交流和合作
- 初学者：能够使用一种语言基本能力的程序员，能够使用子程序、循环、条件语句和其他许多语言特征
- 中间者：有使用多种语言的能力，至少非常熟悉某一种语言
- 专家：对其语言或环境有很深的造诣
- 大师：有专家那样的专业知识，并能意识到编程知识15%和计算机交流，其余85%适合人打交道

### 创造力和纪律
一个杰出的程序员需要遵守许多规则，需要在开始编码前分析需求进行设计，在编码过程中学到关于项目的相关信息，完成一个艺术品。

### 懒惰
- 编写一个工具来完成自己讨厌的工作以解脱自己

### 坚持

### 经验

### 习惯

### 个人性格小结
- 你的个人性格直接影响你编写计算机程序的能力。
- 最有明显作用的性格为：谦虚、好奇心、诚实、创造性和纪律，还有文明的“懒惰”。
- 高级程序员的发展和生成与天才并无多大联系，任何事情都和个人的发展有关。
- 令人吃惊的是，小聪明、经验、坚持和欲望既可帮助你也能妨碍你。
- 许多程序员不主动去吸收新信息和新技术，而是靠偶然地上获得一些新信息，如果你抽出少量时间学习别人的编程经验，过一段时间后，你将在你的同行中脱颖而出。
- 好的性格对养成良好习惯有很大影响，为了成为一位高水平的程序员，你应养成良好的习惯，其余的就会随之而来。


## 三十二、软件开发方法的有关问题
### 克服复杂性
减少复杂性的方法
- 将系统分成子系统
- 减少全局变量
- 将控制结构限制在对 if 和 for 语句的使用
- 为主要数据结构编制具体实现细节
- 编码约定，标准化程序的格式、循环和变量名
- 使用层次结构

抽象和复杂
- 抽象是另一种通过在不同的层次哈桑处理不同的细节来降低复杂性的


### 精选开发过程
软件开发和相应的过程有很大的关系

### 首先为人编写程序，其次才是计算机
算法精确、结构紧凑、有效率并且注释得体
- 可理解性
- 可检查型
- 错误率
- 调试
- 可修改性
- 开发时间
- 外部质量

### 注意约定的使用


### 根据问题范围编程
处理复杂性的一个特定的方法是在最高可能的抽象级上工作
- 将问题分解成不同的抽象级
    - 高级语言结构
    - 计算机科学结构
    - 低级问题领域
    - 高级问题领域

在问题领域采用低级方法
- 在问题领域使用抽象数据类型以实现有实际意义的结构。
- 隐含有关计算机结构和实现细节的有关信息。
- 在面向对象的程序中，设计和问题有直接关系的成员，压缩问题领域中的有关信息。
- 对有意义的字符串和数字使用命名常量。
- 对中间计算结果使用中间变量。
- 使用布尔函数以净化复杂布尔测试。 

### 当心飞来之祸
- 在程序开发中的仔细程度在很大程度上决定了程序的质量，对警告信息的注意程度对最终产品有所影响

### 重构
- 在许多软件开发活动中，重构是合适的。

### 不要固执己见
- 偏执在软件开发过程中有着各种变种：顽固的坚持某种设计方法，执着于某种特定的格式或注释风格，一味的不用goto语句，它都是不正确的。要学会判断和选择。

### 软件开发方法的有关问题小结
- 程序编制的一个主要目的复杂性管理。
- 编程过程对最终产品的影响比人们想象中的要大。
- 合作程序开发要求各成员之间进行广泛的交流，其次才是和计算机的交流，而个人则主要是和你自己而不是和计算机交流。
- 当被乱用时，约定好比是雪上加霜，而使用得当的话，约定可增加开发环境的有用结构，并有助于管理复杂性和交流。
- 面向问题而不是解答的编程有助于对复杂性的管理。
- 注意警告信息是相当重要的，因为编程几乎是纯智力活动。
- 在开发过程重复越多，产品质量也就越高。
- 武断的方法和高质量软件开发是不相容的。你应知道各种程序编制的方法，并能从中挑选出适合你工作的方法。
