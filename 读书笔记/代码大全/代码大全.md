# 代码大全

- [一、欢迎进入软件创建世界](#一、欢迎进入软件创建世界)
    - [软件开发的工作的主要方面](#软件开发的工作的主要方面)
    - [软件创建的重要性](#软件创建的重要性)
    - [欢迎进入软件创建世界小结](#欢迎进入软件创建世界小结)
- [二、利用隐喻对编程进行更深刻的理解](#二、利用隐喻对编程进行更深刻的理解)
    - [利用隐喻对编程进行更深刻的理解小结](#利用隐喻对编程进行更深刻的理解小结)
- [三、软件创建的先决条件](#三、软件创建的先决条件)
    - [先决条件的重要性](#先决条件的重要性)
    - [问题定义先决条件](#问题定义先决条件)
    - [需求分析先决条件](#需求分析先决条件)
        - [需求分析先决条件检查表](#需求分析先决条件检查表)
    - [结构设计先决条件](#结构设计先决条件)
        - [结构设计先决条件检查表](#结构设计先决条件检查表)
    - [选择语言的先决条件](#选择语言的先决条件)
    - [编程约定](#编程约定)
    - [软件创建的先决条件小结](#软件创建的先决条件小结)
- [四、建立子程序的步骤](#四、建立子程序的步骤)
    - [建立子程序的步骤小结](#建立子程序的步骤小结)
- [五、高质量子程序的特点](#五、高质量子程序的特点)
    - [高质量子程序的特点小结](#高质量子程序的特点小结)
- [六、模块化设计](#六、模块化设计)
- [七、高级结构设计](#七、高级结构设计)
- [八、生成数据](#八、生成数据)
- [九、数据名称](#九、数据名称)
- [十、变量](#十、变量)
- [十一、基本数据类型](#十一、基本数据类型)
- [十二、复杂数据类型](#十二、复杂数据类型)
- [十三、顺序程序语句](#十三、顺序程序语句)
- [十四、条件语句](#十四、条件语句)
- [十五、循环语句](#十五、循环语句)
- [十六、少见的控制结构](#十六、少见的控制结构)

## 一、欢迎进入软件创建世界

### 软件开发的工作的主要方面
- 问题定义 system specification
- 需求分析 requirements analysis
- 实现计划 
- 总体设计 architecural design
- 详细设计 detailed design
- 创建即实现 coding and debugging
    - 验证基础工作已经完成，可以进行创建工作
    - 设计和编写子程序与模块
    - 创立数据类型并命名变量
    - 选择控制结构并组织语句块
    - 找出错误并修正
    - 评审其他小组的细节设计和代码，同时接受其他小组评审
    - 通过仔细地格式化和征集意见改进编码
    - 对分别完成的软件单元进行综合
    - 调整编码使其更小、更快
- 系统综合 
- 单元测试 unit testing
- 系统测试 system testing
- 校正性维护 maintenance
- 功能强化 

### 软件创建的重要性
1. 创建活动是开发软件的重要组成部分
2. 创建活动在软件开发中处于枢纽地位
3. 把主要精力集中于创建活动，可以极大地提高程序员的工作效率
4. 创建活动的产品，源代码，往往是软件的唯一精确描述
5. 创建活动是唯一一项必不可少的工作

### 欢迎进入软件创建世界小结
- 创建活动是总体设计和系统测试之间承上启下的工作。
- 创建活动主要包括：详细设计、编码、调试和单元测试。
- 关于创建活动的其它称谓有：实现、编程等。
- 创建活动质量对软件质量有潜在影响。
- 在最后的分析中，对创建活动理解的好坏，决定了一个程序员素质的高低。




## 二、利用隐喻对编程进行更深刻的理解
常用隐喻：
- 软件书写：写代码 Write Code
- 软件播种：生成系统 Growing a System
- 软件珍珠培植法：系统积累 System Accretion
- 软件创建：建造软件 building software
- 实用软件技术：智能工具箱 The Intellectual Toolbox

### 利用隐喻对编程进行更深刻的理解小结
隐喻仅仅是启发，而不是公式，因此，它们更倾向于比较随便，无拘无束。
- 隐喻通过把软件开发与你所熟知的事情联系在一起，从而使你对其有更深刻的理解。
- 一些隐喻要好于其它隐喻。
- 把软件创建与建造建筑物类比，表明开发软件前要精心准备，并表明了大规模项目与小规模项目之间的差别。
- 认为软件开发实践是智能工具箱中的工具进一步表明，每个程序员都有许多自己的工具，没有任何一种工具是万能的。为每件工作选择合适的工具，是成为一个优秀程序员的首要素质之一。




## 三、软件创建的先决条件
### 先决条件的重要性
在进行创建工作前必须做准备工作的论据
- 逻辑推理：
    - 运行有效程序设计的关键之一就是认识到准备工作是非常重要的
- 类比：
    - 创建一个软件系统与其他需要耗费人力与财力的工程是一样的
- 数据
    - 研究证明，一次完成是最好的选择，不必要的修改是非常昂贵的

错误引入和发现时间不同，产生修复他们所要耗费的相对成本差异：
| 错误发现时间 | 需求分析 | 细节设计 | 编码 |
| ------------ | -------- | -------- | ---- |
| 需求分析     | 1        | -        | -    |
| 细节设计     | 2        | 1        | -    |
| 波动测试     | 5        | 2        | 1    |
| 结构测试     | 15       | 5        | 2    |
| 功能测试     | 25       | 10       | 5    |

### 问题定义先决条件
问题定义只描述要解决的问题是什么，根本不涉及解决方法。
问题定义应该从用户的观点出发，使用用户的语言进行定义。

### 需求分析先决条件
在创建各阶段如何应对需求变化：
- 用检查表评估需求分析质量
- 让每个人都知道由于变化需求所付出的代价
- 建立一套更改控制过程
- 用开发的方法来容纳变动
- 放弃项目

#### 需求分析先决条件检查表
**需求内容**
- 系统的所有输入都定义了吗？包括他们的来源、精度、取值范围和频率？
- 系统所有的输出都定义了吗？包括他们的目标、精度、取值范围、频率和格式？
- 所有的报告格式都定义了吗？
- 所有的硬件与软件接口都定义了吗？
- 所有的通信交互界面都定义了吗？包括握手、错误检查以及通信约定？
- 是否从用户的观点出发，定义了所有的必要操作的反应时间？
- 是否定义了时间问题，如处理时间、数据传输率以及系统吞吐能力？
- 是否对用户所有要求完成的任务都作出了规定？
- 每项任务所需用到和产生的数据都规定了吗？
- 规定保密级别了吗？
- 规定可靠性了吗？包括软件出错的后果、在出错时要保护的至关重要的信息、以及错误测试和恢复策略。
- 规定所需最大内存了吗？
- 所需最大存储容量规定了吗？
- 对系统的维护性是否作出了规定？包括系统对运行环境、精度、性能与其他软件的接口等方面变化的适应能力规定了吗？
- 是否规定了相互冲突的设计之间的折衷原则，例如，在坚固性与准确性之间如何进行折衷？
- 是否制定了系统成败的标准？

**关于需求的完善性**
- 在开发开始前暂时得不到的信息是什么？是否规定了不够完善的区域？
- 需求定义是否已经完善到了可以成为软件标准的地步？
- 需求中是否有那一部分令你感到不安？有没有根本不可能实现，而仅仅是为了取悦老板和用户才加进来的内容？

**关于需求的质量**
- 需求是否是用用户的语言制定的？用户也是这样认为的吗？
- 需求中是否每一条之间都尽量避免冲突？
- 需求中是否注意了避免规定设计工作？
- 需求在详细程度方面是否保持了一致性：有没有应该更详细的需求？有没有应该更简略些的？
- 需求是否明确到可以分为一些独立的可执行部分，而每一部分又都很明确？
- 是否每一条都与问题的答案相关？是否每一条都可以追溯到产生它的环境中？
- 是否每一条需求都可以作为测试依据？是否可以针对每一条进行单独测试以确定是否满足需求？
- 是否对可能的改动作出了规定？包括每一条改动的可能性？

### 结构设计先决条件
典型的结构要素：
- 程序的组织形式
- 变更策略：设计中已经考虑到了可能的功能增强变动，而且，应该使最可能的变动同时是最容易实现的变动。
- 购买而不是建造的决定：重新使用旧软件是提高生产率的首要因素。购买代码可以降低计划、详细设计、测试和调试的工作量。
- 主要的数据结构
    - 关键算法
- 主要对象
- 通用功能
    - 用户界面
    - 输入/输出
    - 内存管理
    - 字符串存储
- 错误处理
    - 错误处理是纠正错误还是仅仅测试错误？
    - 错误测试时主动还是被动的？
    - 程序是怎样对付错误的？
    - 处理错误信息的约定是什么呢？
    - 在程序中，应该在哪一个层次上处理错误呢？
    - 每一个模块检验输入数据合法性的责任级别有多搞？
- 坚固性 Robustness
    - 裕度设计 over-engineering 
    - 断言 assertions 
    - 容错性 fault toerance
        - 系统可以返回并重新开始
        - 发现错误时，系统可以用辅助代码来代替基本代码
        - 系统可以采用投票算法
        - 系统可以用一个假想值来代替错误的结果，以避免对程序其余部分的不良影响
    - 性能

通用结构设计质量准则
#### 结构设计先决条件检查表
- 软件的总体组织形式是否清晰明了？包括对与结构设计的总体评论与描述。
- 模块定义是否清楚？包括他们呢的功能以及与其他模块的接口。
- 要求定义中所提出的所有功能，是否有恰当数量的模块覆盖？
- 结构设计是否考虑了可能的更改？
- 是否包括了必要的购买？
- 是否阐明了如何改进重新启用的代码来满足现在的结构设计需求？
- 是否描述并验证了所有主要的数据结构？
- 主要数据结构是否隐藏在存取子程序中？
- 规定数据库组织形式和其他内容了吗？
- 是否说明并验证所有关键算法？
- 是否说明验证所有主要目标？
- 说明处理用户输入的策略了吗？
- 说明并验证处理输入/输出的策略了吗？
- 是否定义了用户界面的关键方面？
- 用户界面是否进行了模块化，以使对它所作的改动不会影响程序其他部分
- 是否描述并验证了内存使用估算和内存管理
- 是否对每一模块给出了存储空间和速度限制
- 是否说明了字符串处理策略？是否提供了对字符串占用空间的估计？
- 所提供的错误处理策略是否一致？
- 是否对错误信息进行了成套化管理以提供一个整洁的用户界面？
- 是否指定了坚固性级别？
- 有没有哪一部分结构设计被过分定义或缺少定义了？
- 是否明确提出了系统目标？
- 整个结构在概念哈桑是否一致？
- 机器和使用实现语言是否顶层设计依赖？
- 给出做出每个重要决定的动机了吗？
- 你作为系统实现者的程序员，对结构设计满意吗？

### 选择语言的先决条件
当程序员使用自己所熟悉的语言时，其工作效率比使用陌生的语言高得多。

### 编程约定
实现时在给变量和子程序命名、进行格式约定和注释约定时的指导方针。

### 软件创建的先决条件小结
- 如果想开发一个高质量的软件，必须自始至终重视质量问题。在开始阶段强调质量往往比在最后强调质量更为有效。
- 程序员的份内工作之一便是向老板和同事宣传软件的开发过程，包括在编程开始前从事先决条件准备工作的重要性。
- 如果问题定义工作做得不好，那么在创建阶段，所解决的问题可能并不是用户真正要解决的问题。
- 如果需求分析工作做得不好，很可能因此而漏掉要解决问题中的重要细节。在创建工作后更改要求，要比在需求分析阶段进行更改的成本高 20 到 100 倍。所以，在开始编程前一定要确认要求定义工作一切正常。
- 在编程前规定好约定，在创建工作结束后再改变代码来满足约定几乎是不可能的。
- 在创建活动开始之前如果无法完成准备工作，可以尝试在不太稳固的基础上进行创建活动。



## 四、建立子程序的步骤
### PDL(程序设计语言)
定义：
- 用模拟英语的语句来精确描述每一个特定的操作
- 避免使用最终程序语言的语句
- 在设计意向这一层次上写PDL
- 在足够低的层次上写出PDL，它几乎可以自动生成代码

例子：
``` txt
Keep track of current number of resource in use
If another resource is available
    Allocate a dialog box structure
    If a dialog box structure could be allocated
        Note that one more resource is in use
        Initialize the resource
        Store the resource number at the location provided by the caller
    Endif
Endif
Return TRUE if a new resource was created; else return FALSE
```

更高层级例子：
``` txt
This routine outputs an error message based on an error code supplied by the calling routine. The way it outputs the message depends on the current processing state, which it retrieves on its own. It returns a variable indicating success or failure.

set the default status
look up the message based on the error code
if the error code is valid 
    datermine the processing method
    if doing interactive processing
        print the error message interactively and declare success
    else doing batch processing
        if the batch message file opens properly
            log the error message to the batch file,
                close the file, and declare success
else the message code is not valid
    notify the user that an interal error has been detected
```

优点：
- PDL可以使评审工作变得更容易
- PDL可以帮助实现逐步细化的思想
- PDL使变动工作变得很容易
- PDL极大的减少了注释工作量
- PDL比其他形式的设计文件更容易维护

### 设计子程序
结构设计需要指出的问题：
- 这个子程序将要隐含的信息
- 这个子程序的输入
- 这个子程序的输出，包括受影响的全局变量
- 这个子程序将如何处理错误

步骤：
- 给子程序命名
- 考虑效率
- 研究算法和数据结构
- 编写PDL
- 编写工作应该从抽象到具体
- 考虑数据
- 逐步细化
- 书写子程序说明
- 非正式的检查代码
- 进行收尾工作
    - 检查子程序的接口
    - 检查通用设计质量
    - 检查子程序的数据
    - 检查子程序控制结构
    - 检查子程序设计
    - 检查子程序的文档
- 按需要重复步骤


### 建立子程序的步骤小结
- 要想写好 PDL，首先要用易懂的自然语言，避免拘泥于某种程序语言，其次要在意向层次上写 PDL，描述设计作什么而不是如何作。
- PDL 到代码流程方法是详细设计的有力工具，而且使得编码非常容易。可以把 PDL 直接翻译成注释，但要注意保证注释是精确而有用的。
- 应该在工作的每一步中都检查子程序，并鼓励同事们检查。这样，可以在投入的资金和工作努力最少时便发现错误，从而极大降低改错成本。



## 五、高质量子程序的特点

### 高质量子程序的特点小结
建立子程序的最重要原因是加强可管理性（即降低复杂性），其它原因还有节省空间、改进正确性、可靠性、可修改性等等。
- 强调强内聚性和松散耦合的首要原因是它们提供了较高层次的抽象性，你可以认为一个具备这种特性的子程序运行是独立的，这可以使你集中精力完成其它任务。
- 有些情况下，放入子程序而带来巨大收益的操作可能是非常简单的。
- 子程序的名称表明了它的质量，如果名称不好但却是精确的，那么说明它的设计也是非常令人遗憾的。如果一个子程序的名称既不好又不精确，那它根本就无法告诉你程序作了些什么。无论哪种情况，都说明程序需要改进。
- 防错性编程可以使错误更容易被发现和修复，对最终软件的危害性显著减小。


## 六、模块化设计

## 七、高级结构设计

## 八、生成数据

## 九、数据名称

## 十、变量

## 十一、基本数据类型

## 十二、复杂数据类型

## 十三、顺序程序语句

## 十四、条件语句

## 十五、循环语句

## 十六、少见的控制结构

## 十七、常见的控制问题

## 十八、布局和风格

## 十九、文档

## 二十、编程工具

## 二十一、项目大小如何影响创建

## 二十二、创建管理

## 二十三、软件质量概述

## 二十四、评审

## 二十五、单元测试

## 二十六、调试

## 二十七、系统集成

## 二十八、代码调整策略

## 二十九、代码调试技术

## 三十、软件优化

## 三十一、个人性格



