# 代码大全

- [一、欢迎进入软件创建世界](#一、欢迎进入软件创建世界)
    - [软件开发的工作的主要方面](#软件开发的工作的主要方面)
    - [软件创建的重要性](#软件创建的重要性)
    - [欢迎进入软件创建世界小结](#欢迎进入软件创建世界小结)
- [二、利用隐喻对编程进行更深刻的理解](#二、利用隐喻对编程进行更深刻的理解)
    - [利用隐喻对编程进行更深刻的理解小结](#利用隐喻对编程进行更深刻的理解小结)
- [三、软件创建的先决条件](#三、软件创建的先决条件)
    - [先决条件的重要性](#先决条件的重要性)
    - [问题定义先决条件](#问题定义先决条件)
    - [需求分析先决条件](#需求分析先决条件)
        - [需求分析先决条件检查表](#需求分析先决条件检查表)
    - [结构设计先决条件](#结构设计先决条件)
        - [结构设计先决条件检查表](#结构设计先决条件检查表)
    - [选择语言的先决条件](#选择语言的先决条件)
    - [编程约定](#编程约定)
    - [软件创建的先决条件小结](#软件创建的先决条件小结)
- [四、建立子程序的步骤](#四、建立子程序的步骤)
    - [建立子程序的步骤小结](#建立子程序的步骤小结)
- [五、高质量子程序的特点](#五、高质量子程序的特点)
    - [高质量子程序的特点小结](#高质量子程序的特点小结)
- [六、模块化设计](#六、模块化设计)
- [七、高级结构设计](#七、高级结构设计)
- [八、生成数据](#八、生成数据)
- [九、数据名称](#九、数据名称)
- [十、变量](#十、变量)
- [十一、基本数据类型](#十一、基本数据类型)
- [十二、复杂数据类型](#十二、复杂数据类型)
- [十三、顺序程序语句](#十三、顺序程序语句)
- [十四、条件语句](#十四、条件语句)
- [十五、循环语句](#十五、循环语句)
- [十六、少见的控制结构](#十六、少见的控制结构)
- [十七、常见的控制问题](#十七、常见的控制问题)
- [十八、布局和风格](#十八、布局和风格)
- [十九、文档](#十九、文档)
- [二十、编程工具](#二十、编程工具)
- [二十一、项目大小如何影响创建](#二十一、项目大小如何影响创建)
- [二十二、创建管理](#二十二、创建管理)
- [二十三、软件质量概述](#二十三、软件质量概述)
- [二十四、评审](#二十四、评审)
- [二十五、单元测试](#二十五、单元测试)
- [二十六、调试](#二十六、调试)
- [二十七、系统集成](#二十七、系统集成)
- [二十八、代码调整策略](#二十八、代码调整策略)
- [二十九、代码调试技术](#二十九、代码调试技术)
- [三十、软件优化](#三十、软件优化)
- [三十一、个人性格](#三十一、个人性格)
    - [聪明和谦虚](#聪明和谦虚)
    - [好奇心](#好奇心)
    - [诚实](#诚实)
    - [交流和合作](#交流和合作)
    - [创造力和纪律](#创造力和纪律)
    - [懒惰](#懒惰)
    - [坚持](#坚持)
    - [经验](#经验)
    - [习惯](#习惯)
    - [个人性格小结](#个人性格小结)
- [三十二、软件开发方法的有关问题](#三十二、软件开发方法的有关问题)

## 一、欢迎进入软件创建世界

### 软件开发的工作的主要方面
- 问题定义 system specification
- 需求分析 requirements analysis
- 实现计划 
- 总体设计 architecural design
- 详细设计 detailed design
- 创建即实现 coding and debugging
    - 验证基础工作已经完成，可以进行创建工作
    - 设计和编写子程序与模块
    - 创立数据类型并命名变量
    - 选择控制结构并组织语句块
    - 找出错误并修正
    - 评审其他小组的细节设计和代码，同时接受其他小组评审
    - 通过仔细地格式化和征集意见改进编码
    - 对分别完成的软件单元进行综合
    - 调整编码使其更小、更快
- 系统综合 
- 单元测试 unit testing
- 系统测试 system testing
- 校正性维护 maintenance
- 功能强化 

### 软件创建的重要性
1. 创建活动是开发软件的重要组成部分
2. 创建活动在软件开发中处于枢纽地位
3. 把主要精力集中于创建活动，可以极大地提高程序员的工作效率
4. 创建活动的产品，源代码，往往是软件的唯一精确描述
5. 创建活动是唯一一项必不可少的工作

### 欢迎进入软件创建世界小结
- 创建活动是总体设计和系统测试之间承上启下的工作。
- 创建活动主要包括：详细设计、编码、调试和单元测试。
- 关于创建活动的其它称谓有：实现、编程等。
- 创建活动质量对软件质量有潜在影响。
- 在最后的分析中，对创建活动理解的好坏，决定了一个程序员素质的高低。




## 二、利用隐喻对编程进行更深刻的理解
常用隐喻：
- 软件书写：写代码 Write Code
- 软件播种：生成系统 Growing a System
- 软件珍珠培植法：系统积累 System Accretion
- 软件创建：建造软件 building software
- 实用软件技术：智能工具箱 The Intellectual Toolbox

### 利用隐喻对编程进行更深刻的理解小结
隐喻仅仅是启发，而不是公式，因此，它们更倾向于比较随便，无拘无束。
- 隐喻通过把软件开发与你所熟知的事情联系在一起，从而使你对其有更深刻的理解。
- 一些隐喻要好于其它隐喻。
- 把软件创建与建造建筑物类比，表明开发软件前要精心准备，并表明了大规模项目与小规模项目之间的差别。
- 认为软件开发实践是智能工具箱中的工具进一步表明，每个程序员都有许多自己的工具，没有任何一种工具是万能的。为每件工作选择合适的工具，是成为一个优秀程序员的首要素质之一。




## 三、软件创建的先决条件
### 先决条件的重要性
在进行创建工作前必须做准备工作的论据
- 逻辑推理：
    - 运行有效程序设计的关键之一就是认识到准备工作是非常重要的
- 类比：
    - 创建一个软件系统与其他需要耗费人力与财力的工程是一样的
- 数据
    - 研究证明，一次完成是最好的选择，不必要的修改是非常昂贵的

错误引入和发现时间不同，产生修复他们所要耗费的相对成本差异：
| 错误发现时间 | 需求分析 | 细节设计 | 编码 |
| ------------ | -------- | -------- | ---- |
| 需求分析     | 1        | -        | -    |
| 细节设计     | 2        | 1        | -    |
| 波动测试     | 5        | 2        | 1    |
| 结构测试     | 15       | 5        | 2    |
| 功能测试     | 25       | 10       | 5    |

### 问题定义先决条件
问题定义只描述要解决的问题是什么，根本不涉及解决方法。
问题定义应该从用户的观点出发，使用用户的语言进行定义。

### 需求分析先决条件
在创建各阶段如何应对需求变化：
- 用检查表评估需求分析质量
- 让每个人都知道由于变化需求所付出的代价
- 建立一套更改控制过程
- 用开发的方法来容纳变动
- 放弃项目

#### 需求分析先决条件检查表
**需求内容**
- 系统的所有输入都定义了吗？包括他们的来源、精度、取值范围和频率？
- 系统所有的输出都定义了吗？包括他们的目标、精度、取值范围、频率和格式？
- 所有的报告格式都定义了吗？
- 所有的硬件与软件接口都定义了吗？
- 所有的通信交互界面都定义了吗？包括握手、错误检查以及通信约定？
- 是否从用户的观点出发，定义了所有的必要操作的反应时间？
- 是否定义了时间问题，如处理时间、数据传输率以及系统吞吐能力？
- 是否对用户所有要求完成的任务都作出了规定？
- 每项任务所需用到和产生的数据都规定了吗？
- 规定保密级别了吗？
- 规定可靠性了吗？包括软件出错的后果、在出错时要保护的至关重要的信息、以及错误测试和恢复策略。
- 规定所需最大内存了吗？
- 所需最大存储容量规定了吗？
- 对系统的维护性是否作出了规定？包括系统对运行环境、精度、性能与其他软件的接口等方面变化的适应能力规定了吗？
- 是否规定了相互冲突的设计之间的折衷原则，例如，在坚固性与准确性之间如何进行折衷？
- 是否制定了系统成败的标准？

**关于需求的完善性**
- 在开发开始前暂时得不到的信息是什么？是否规定了不够完善的区域？
- 需求定义是否已经完善到了可以成为软件标准的地步？
- 需求中是否有那一部分令你感到不安？有没有根本不可能实现，而仅仅是为了取悦老板和用户才加进来的内容？

**关于需求的质量**
- 需求是否是用用户的语言制定的？用户也是这样认为的吗？
- 需求中是否每一条之间都尽量避免冲突？
- 需求中是否注意了避免规定设计工作？
- 需求在详细程度方面是否保持了一致性：有没有应该更详细的需求？有没有应该更简略些的？
- 需求是否明确到可以分为一些独立的可执行部分，而每一部分又都很明确？
- 是否每一条都与问题的答案相关？是否每一条都可以追溯到产生它的环境中？
- 是否每一条需求都可以作为测试依据？是否可以针对每一条进行单独测试以确定是否满足需求？
- 是否对可能的改动作出了规定？包括每一条改动的可能性？

### 结构设计先决条件
典型的结构要素：
- 程序的组织形式
- 变更策略：设计中已经考虑到了可能的功能增强变动，而且，应该使最可能的变动同时是最容易实现的变动。
- 购买而不是建造的决定：重新使用旧软件是提高生产率的首要因素。购买代码可以降低计划、详细设计、测试和调试的工作量。
- 主要的数据结构
    - 关键算法
- 主要对象
- 通用功能
    - 用户界面
    - 输入/输出
    - 内存管理
    - 字符串存储
- 错误处理
    - 错误处理是纠正错误还是仅仅测试错误？
    - 错误测试时主动还是被动的？
    - 程序是怎样对付错误的？
    - 处理错误信息的约定是什么呢？
    - 在程序中，应该在哪一个层次上处理错误呢？
    - 每一个模块检验输入数据合法性的责任级别有多搞？
- 坚固性 Robustness
    - 裕度设计 over-engineering 
    - 断言 assertions 
    - 容错性 fault toerance
        - 系统可以返回并重新开始
        - 发现错误时，系统可以用辅助代码来代替基本代码
        - 系统可以采用投票算法
        - 系统可以用一个假想值来代替错误的结果，以避免对程序其余部分的不良影响
    - 性能

通用结构设计质量准则
#### 结构设计先决条件检查表
- 软件的总体组织形式是否清晰明了？包括对与结构设计的总体评论与描述。
- 模块定义是否清楚？包括他们呢的功能以及与其他模块的接口。
- 要求定义中所提出的所有功能，是否有恰当数量的模块覆盖？
- 结构设计是否考虑了可能的更改？
- 是否包括了必要的购买？
- 是否阐明了如何改进重新启用的代码来满足现在的结构设计需求？
- 是否描述并验证了所有主要的数据结构？
- 主要数据结构是否隐藏在存取子程序中？
- 规定数据库组织形式和其他内容了吗？
- 是否说明并验证所有关键算法？
- 是否说明验证所有主要目标？
- 说明处理用户输入的策略了吗？
- 说明并验证处理输入/输出的策略了吗？
- 是否定义了用户界面的关键方面？
- 用户界面是否进行了模块化，以使对它所作的改动不会影响程序其他部分
- 是否描述并验证了内存使用估算和内存管理
- 是否对每一模块给出了存储空间和速度限制
- 是否说明了字符串处理策略？是否提供了对字符串占用空间的估计？
- 所提供的错误处理策略是否一致？
- 是否对错误信息进行了成套化管理以提供一个整洁的用户界面？
- 是否指定了坚固性级别？
- 有没有哪一部分结构设计被过分定义或缺少定义了？
- 是否明确提出了系统目标？
- 整个结构在概念哈桑是否一致？
- 机器和使用实现语言是否顶层设计依赖？
- 给出做出每个重要决定的动机了吗？
- 你作为系统实现者的程序员，对结构设计满意吗？

### 选择语言的先决条件
当程序员使用自己所熟悉的语言时，其工作效率比使用陌生的语言高得多。

### 编程约定
实现时在给变量和子程序命名、进行格式约定和注释约定时的指导方针。

### 软件创建的先决条件小结
- 如果想开发一个高质量的软件，必须自始至终重视质量问题。在开始阶段强调质量往往比在最后强调质量更为有效。
- 程序员的份内工作之一便是向老板和同事宣传软件的开发过程，包括在编程开始前从事先决条件准备工作的重要性。
- 如果问题定义工作做得不好，那么在创建阶段，所解决的问题可能并不是用户真正要解决的问题。
- 如果需求分析工作做得不好，很可能因此而漏掉要解决问题中的重要细节。在创建工作后更改要求，要比在需求分析阶段进行更改的成本高 20 到 100 倍。所以，在开始编程前一定要确认要求定义工作一切正常。
- 在编程前规定好约定，在创建工作结束后再改变代码来满足约定几乎是不可能的。
- 在创建活动开始之前如果无法完成准备工作，可以尝试在不太稳固的基础上进行创建活动。



## 四、建立子程序的步骤
### PDL(程序设计语言)
定义：
- 用模拟英语的语句来精确描述每一个特定的操作
- 避免使用最终程序语言的语句
- 在设计意向这一层次上写PDL
- 在足够低的层次上写出PDL，它几乎可以自动生成代码

例子：
``` txt
Keep track of current number of resource in use
If another resource is available
    Allocate a dialog box structure
    If a dialog box structure could be allocated
        Note that one more resource is in use
        Initialize the resource
        Store the resource number at the location provided by the caller
    Endif
Endif
Return TRUE if a new resource was created; else return FALSE
```

更高层级例子：
``` txt
This routine outputs an error message based on an error code supplied by the calling routine. The way it outputs the message depends on the current processing state, which it retrieves on its own. It returns a variable indicating success or failure.

set the default status
look up the message based on the error code
if the error code is valid 
    datermine the processing method
    if doing interactive processing
        print the error message interactively and declare success
    else doing batch processing
        if the batch message file opens properly
            log the error message to the batch file,
                close the file, and declare success
else the message code is not valid
    notify the user that an interal error has been detected
```

优点：
- PDL可以使评审工作变得更容易
- PDL可以帮助实现逐步细化的思想
- PDL使变动工作变得很容易
- PDL极大的减少了注释工作量
- PDL比其他形式的设计文件更容易维护

### 设计子程序
结构设计需要指出的问题：
- 这个子程序将要隐含的信息
- 这个子程序的输入
- 这个子程序的输出，包括受影响的全局变量
- 这个子程序将如何处理错误

步骤：
- 给子程序命名
- 考虑效率
- 研究算法和数据结构
- 编写PDL
- 编写工作应该从抽象到具体
- 考虑数据
- 逐步细化
- 书写子程序说明
- 非正式的检查代码
- 进行收尾工作
    - 检查子程序的接口
    - 检查通用设计质量
    - 检查子程序的数据
    - 检查子程序控制结构
    - 检查子程序设计
    - 检查子程序的文档
- 按需要重复步骤


### 检查子程序
- 在心里对子程序进行查错处理
- 编译子程序
    - 尽可能把比那一程序的警告等级调到最高
    - 消除所有编译程序指出的错误和提出警告的原因
- 使用计算机来检查子程序错误
- 消除子程序错误

#### 创建子程序检查表
- 是否检查过先决条件是否已经满足了
- 定义子程序将要解决的问题了吗
- 结构设计是否足够清楚，使得你可以给子程序取个好名字
- 考虑如何测试子程序了吗
- 是否从模块化水平或者满足时间和内存要求角度考虑过效率问题
- 是否查阅过参考书：以寻求有帮助的算法
- 是否用详尽的PDL设计子程序
- 在必要时，是否在逻辑设计步骤前考虑了数据
- 是否检查过PDL，它很容易理解吗
- 是否注意到了足以使你返回结构设计阶段的警告
- 是否使用了PDL到代码流程，是否把PDL作为编码基础并把所有的PDL转为注释
- 是否精确地把PDL翻译成了代码
- 在作出假设时，验证它们了吗
- 是从几个设计方案中选择了最好的，还是随意选择了一个方案
- 是否彻底理解你的代码，它容易理解吗

### 建立子程序的步骤小结
- 要想写好 PDL，首先要用易懂的自然语言，避免拘泥于某种程序语言，其次要在意向层次上写 PDL，描述设计作什么而不是如何作。
- PDL 到代码流程方法是详细设计的有力工具，而且使得编码非常容易。可以把 PDL 直接翻译成注释，但要注意保证注释是精确而有用的。
- 应该在工作的每一步中都检查子程序，并鼓励同事们检查。这样，可以在投入的资金和工作努力最少时便发现错误，从而极大降低改错成本。



## 五、高质量子程序的特点
### 生成子程序的原因
- 降低复杂性
- 避免重复代码段
- 限制了改动带来的影响
- 隐含顺序
- 改进性能
- 进行集中控制
- 隐含数据结构
- 隐含全局变量
- 隐含指针操作
- 促进重新使用代码段
- 计划开发一个软件族
    - 如果想改进一个程序，最好把要改动的那部分放进子程序中，将其独立
- 提高部分代码的可读性
- 提高可移植性
- 分隔复杂操作
- 独立非标准语言函数的使用
- 简化复杂的布尔测试

### 子程序名称恰当
- 对过程的名字，可以用一个较强的动词带目标的形式
    - PrintReport / CheckOrderInfo
    - RePort.Print / OrderInfo.Check
- 对于函数名称，可以用返回值描述
    - Cos / PrinterReady / CurrentPenColor
- 避免无意义或模棱两可的动词
    -  ~~HandleCalculation / ProcessInput~~
- 描述子程序所做的而一切
    - ~~ComputeReportTotal~~
    - ~~TotalAndSetPrintingReadyVar~~
- 名字的长度要复合需要
- 建立用于通用操作的约定
    - GetInputChar / QueryInputChar

### 强内聚性
- 功能内聚
    - sin(), GetCustomerName(), EraseFile()
- 顺序内聚
    - DoStep1() / DoStep2()
- 通讯内聚型
    - GetNameAndChangePhoneNumber()
- 临时内聚性
    - Startup() / CompleteNewEmployee() / Shutdown()


### 高质量子程序的特点小结
建立子程序的最重要原因是加强可管理性（即降低复杂性），其它原因还有节省空间、改进正确性、可靠性、可修改性等等。
- 强调强内聚性和松散耦合的首要原因是它们提供了较高层次的抽象性，你可以认为一个具备这种特性的子程序运行是独立的，这可以使你集中精力完成其它任务。
- 有些情况下，放入子程序而带来巨大收益的操作可能是非常简单的。
- 子程序的名称表明了它的质量，如果名称不好但却是精确的，那么说明它的设计也是非常令人遗憾的。如果一个子程序的名称既不好又不精确，那它根本就无法告诉你程序作了些什么。无论哪种情况，都说明程序需要改进。
- 防错性编程可以使错误更容易被发现和修复，对最终软件的危害性显著减小。


## 六、模块化设计

## 七、高级结构设计

## 八、生成数据

## 九、数据名称

## 十、变量

## 十一、基本数据类型

## 十二、复杂数据类型

## 十三、顺序程序语句

## 十四、条件语句

## 十五、循环语句

## 十六、少见的控制结构

## 十七、常见的控制问题

## 十八、布局和风格

## 十九、文档

## 二十、编程工具

## 二十一、项目大小如何影响创建

## 二十二、创建管理

## 二十三、软件质量概述

## 二十四、评审

## 二十五、单元测试

## 二十六、调试

## 二十七、系统集成

## 二十八、代码调整策略

## 二十九、代码调试技术

## 三十、软件优化

## 三十一、个人性格
### 聪明和谦虚
"谦虚的程序员"
- "分解"一个系统的目的是为了使其更为简单易懂
- 进行评审、检查和测试使弥补人的错误的一种方法
- 将子程序编短一些有助于减少工作量
- 使用各种交谈方式可将你从编程的死胡同中解放出来

### 好奇心
- 在开发过程中建立自我意思
- 实验
- 阅读解决问题的有关方法
- 在行动前进行分析和计划
- 学习成功项目的开发经验
- 阅读手册
- 阅读有关书籍和期刊

### 诚实
- 不假装自己是一个编程高手
- 乐于承认自己的错误
- 力图理解编译器警告信息而不是对其置之不理
- 对你的程序有一个清晰的了解，而不是进行编译看其是否有错
- 提供实际状态报告
- 提供实际方案评估，在上级面前坚持自己的意见

### 交流和合作
- 初学者：能够使用一种语言基本能力的程序员，能够使用子程序、循环、条件语句和其他许多语言特征
- 中间者：有使用多种语言的能力，至少非常熟悉某一种语言
- 专家：对其语言或环境有很深的造诣
- 大师：有专家那样的专业知识，并能意识到编程知识15%和计算机交流，其余85%适合人打交道

### 创造力和纪律
一个杰出的程序员需要遵守许多规则，需要在开始编码前分析需求进行设计，在编码过程中学到关于项目的相关信息，完成一个艺术品。

### 懒惰
- 编写一个工具来完成自己讨厌的工作以解脱自己

### 坚持

### 经验

### 习惯

### 个人性格小结
- 你的个人性格直接影响你编写计算机程序的能力。
- 最有明显作用的性格为：谦虚、好奇心、诚实、创造性和纪律，还有文明的“懒惰”。
- 高级程序员的发展和生成与天才并无多大联系，任何事情都和个人的发展有关。
- 令人吃惊的是，小聪明、经验、坚持和欲望既可帮助你也能妨碍你。
- 许多程序员不主动去吸收新信息和新技术，而是靠偶然地上获得一些新信息，如果你抽出少量时间学习别人的编程经验，过一段时间后，你将在你的同行中脱颖而出。
- 好的性格对养成良好习惯有很大影响，为了成为一位高水平的程序员，你应养成良好的习惯，其余的就会随之而来。


## 三十二、软件开发方法的有关问题
### 克服复杂性
减少复杂性的方法
- 将系统分成子系统
- 减少全局变量
- 将控制结构限制在对 if 和 for 语句的使用
- 为主要数据结构编制具体实现细节
- 编码约定，标准化程序的格式、循环和变量名
- 使用层次结构

抽象和复杂
- 抽象是另一种通过在不同的层次哈桑处理不同的细节来降低复杂性的


### 精选开发过程
软件开发和相应的过程有很大的关系

### 首先为人编写程序，其次才是计算机
算法精确、结构紧凑、有效率并且注释得体
- 可理解性
- 可检查型
- 错误率
- 调试
- 可修改性
- 开发时间
- 外部质量

### 注意约定的使用


### 根据问题范围编程
处理复杂性的一个特定的方法是在最高可能的抽象级上工作
- 将问题分解成不同的抽象级
    - 高级语言结构
    - 计算机科学结构
    - 低级问题领域
    - 高级问题领域

在问题领域采用低级方法
- 在问题领域使用抽象数据类型以实现有实际意义的结构。
- 隐含有关计算机结构和实现细节的有关信息。
- 在面向对象的程序中，设计和问题有直接关系的成员，压缩问题领域中的有关信息。
- 对有意义的字符串和数字使用命名常量。
- 对中间计算结果使用中间变量。
- 使用布尔函数以净化复杂布尔测试。 

### 当心飞来之祸
- 在程序开发中的仔细程度在很大程度上决定了程序的质量，对警告信息的注意程度对最终产品有所影响

### 重构
- 在许多软件开发活动中，重构是合适的。

### 不要固执己见
- 偏执在软件开发过程中有着各种变种：顽固的坚持某种设计方法，执着于某种特定的格式或注释风格，一味的不用goto语句，它都是不正确的。要学会判断和选择。

### 软件开发方法的有关问题小结
- 程序编制的一个主要目的复杂性管理。
- 编程过程对最终产品的影响比人们想象中的要大。
- 合作程序开发要求各成员之间进行广泛的交流，其次才是和计算机的交流，而个人则主要是和你自己而不是和计算机交流。
- 当被乱用时，约定好比是雪上加霜，而使用得当的话，约定可增加开发环境的有用结构，并有助于管理复杂性和交流。
- 面向问题而不是解答的编程有助于对复杂性的管理。
- 注意警告信息是相当重要的，因为编程几乎是纯智力活动。
- 在开发过程重复越多，产品质量也就越高。
- 武断的方法和高质量软件开发是不相容的。你应知道各种程序编制的方法，并能从中挑选出适合你工作的方法。
