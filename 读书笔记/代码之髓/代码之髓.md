# 代码之髓

- [如何深入高效地学习语言](##如何深入高效地学习语言)
- [语法的诞生](##语法的诞生)
- [程序流程控制](##程序流程控制)
- [函数](##函数)
- [异常处理](##异常处理)
- [名字和作用域](##名字和作用域)
- [类型](##类型)

## 如何深入高效地学习语言

1. 在比较中学习
    - 通过比较多种语言，总结每种语言的独有特点，以及多种语言共有特点

2. 在历史中学习
    - 追溯语言的发展历史，了解语言是如何产生、变化和消失的，探寻语言发展演变的轨迹

3. 在实践中学习
    - 亲自进行程序设计，边实践边思考如何编程

## 语法的诞生
* FORTH语言->利用栈表示运算逻辑
    - 后缀表达式(波兰表示法)
    - eg: 1 2 +
* LISP语言->利用语法树表示运算逻辑
    - 前缀表达式(逆波兰表示法))
    - eg: * (+ 1 2) 3
* FORTRAN语言->利用正常习惯编写程序
    - 中缀表达式
    - Formula Translating System 表达式翻译系统

### 语法分析器
把源代码作为字符串读入、解析，并建立语法树的程序。需要解决**语法冲突**问题因此部分语言保留复杂的编写规则

## 程序流程控制
让代码结构理解更加简单
- if / while / for / foreach ...

## 函数

将代码的一部分视为一个整体的机制
- 封装-便于理解
- 复用-便于再利用

### 相关概念:

程序 `procedure` 子程序 `subroutine` 函数 `function` 方法 `method`

把需要反复使用的命令封装到一起使用，如果没有返回值，那么函数和子程序概念一样

### 函数的演变:
1. 需要修改程序中跳转命令的跳转目的地，使函数调用后返回原来的位置
2. 函数需要有记录跳转目的地的存储空间和记录返回命令所在地的空间，并在函数调用前修改此空间
3. 如何修改函数会同时影响相应的地址空间
4. 使用专用存储空间会遇到复合调用和递归调用时地址空间被修改问题
5. 使用一个专门的数据结构去存储此信息，即栈

### 栈
- 存储多个值的数据结构
- 先进先出

### 递归
处理嵌套形式的数据

## 异常处理
### 异常处理方式
1. 通过函数返回值传达错误信息，函数调用方通过检查返回值进行异常处理
- 容易遗漏错误
- 代码可读性降低
2. 函数前定义好错误处理代码，错误发生时跳转至相应的错误处理代码
- 异常， throw Exception

### 历史
- UNIVACLI -> 使用中断 `interrupt`，发生异常时进行处理
- COBOL -> 定义了两个关键字专用异常，文件读取异常 `AT END`， ADD溢出异常 `ON SIZE`
- PL/I -> 使用ON语句处理异常
    - PL/I语言使用 GOTO / IF / DO / ON 来处理跳转/条件/循环/异常
- C/C++ -> try-catch
    - 明确声明命令可能抛出何种异常
    - 需要有将可出错语句括起来的结构
    - 使用析构函数来实现finally的功能
- Java/C# -> try-catch-finally
    - 结构化异常处理

### 异常处理关键知识点
- 何时抛出异常
    - 通常在开发/测试阶段发生异常立刻抛出是由价值的
- 异常传递
    - 多数语言会将异常不断冒泡抛出
- Java 异常处理机制
    - 检查型异常，明确声明可能抛出何种异常；一般是可以预期的异常，需要进行异常处理的
    - 非检查型异常，非预期的通常可以避免的异常
    - C#认可此机制但未引用

## 名字和作用域
### 历史
- 对照表，名字和内容之间关系的全局表
    - 需要避免冲突
    1. 取更长的名字
    2. 使用作用域
- 动态作用域，对照表仍是全局表
    - 把变量原来的值存入函数入口，出口处写回
    - 在写回之前执行其他函数会发生错误
- 静态作用域
    - 使用各自的对照表解决问题，避免全局污染

### 特殊类型语言作用域问题 
#### JavaScript
- 未声明变量均为全局变量，使用var声明变量为局部变量

#### Python
- 作用域分为 局部的->文件的->全局的
- 默认使用最小作用域
- 当在函数中给一个变量名赋值是(而不是在一个表达式中对其进行引用)，Python总是创建或改变本地作用域的变量名，除非它已经在那个函数中被声明为全局变量.
- Python3 中使用 nonlocal / gobal 来声明变量作用域

#### Java
- 类的名字具有全局作用域
- 不要使用单例模式替代全局变量

## 类型









